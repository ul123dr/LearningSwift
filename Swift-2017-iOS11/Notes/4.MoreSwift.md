# lecture 4



##  Protocols åè®®

- åè®®æ˜¯ä¸€ç§æ›´ç®€æ´çš„è¡¨è¾¾APIçš„æ–¹æ³•

ä¸æ˜¯å¼ºåˆ¶APIçš„è°ƒç”¨æ–¹ä¼ é€’ç‰¹å®šçš„ç±»ã€ç»“æ„æˆ–æšä¸¾ï¼ŒAPIå¯ä»¥è®©è°ƒç”¨æ–¹ä¼ é€’è°ƒç”¨æ–¹éœ€è¦çš„ä»»ä½•ç±»/ç»“æ„/æšä¸¾ï¼Œä½†å¯èƒ½è¦æ±‚å®ƒä»¬å®ç°APIéœ€è¦çš„æŸäº›æ–¹æ³•å’Œ/æˆ–å±æ€§ã€‚<br>
APIè¡¨ç¤ºå¸Œæœ›è°ƒç”¨è€…ä½¿ç”¨åè®®æä¾›çš„å‡½æ•°æˆ–å˜é‡ã€‚æ‰€ä»¥åè®®åªæ˜¯æ–¹æ³•å’Œå±æ€§å£°æ˜çš„é›†åˆã€‚
    
- åè®®çš„å¥½å¤„

ä½¿APIæ›´åŠ çµæ´»å’Œå…·æœ‰è¡¨ç°åŠ›<br>
(Blind)è§†å›¾å’Œæ§åˆ¶å™¨ä¹‹é—´çš„ç»“æ„åŒ–é€šä¿¡ï¼ˆå§”æ‰˜ï¼‰<br>
å¼ºåˆ¶æ€§ï¼ˆe.g. ä¸€ä¸ª `Dictionary` çš„å€¼é›†å¿…é¡»æ˜¯ `Hashable` ï¼‰<br>
æ–¹ä¾¿ä¸åŒç±»å‹å…±äº«åŠŸèƒ½ï¼ˆ`String`ã€`Array`ã€`CountableRange` éƒ½æ˜¯ `Collections`ï¼‰<br>
å¤šé‡ç»§æ‰¿ï¼ˆä»…åŠŸèƒ½ï¼Œä¸åŒ…æ‹¬æ•°æ®ï¼‰

- åè®®æ˜¯ä¸€ç§ç±»å‹ï¼Œå¯ä»¥åœ¨ä»»ä½•åœ°æ–¹ä½¿ç”¨

åè®®çš„å£°æ˜ï¼šå£°æ˜åè®®ä¸­åŒ…å«çš„å±æ€§å’Œæ–¹æ³•
ç±»ã€ç»“æ„ä½“ã€æšä¸¾å£°æ˜å®ç°è¯¥åè®®
å®ç°ç±»ã€ç»“æ„ä½“ã€æšä¸¾ï¼ˆæˆ–æ‰©å±•ï¼‰ä¸­çš„ç»§æ‰¿çš„åè®®ä»£ç 
    
- åè®®ä¸­çš„å¯é€‰æ–¹æ³• Optional methods

ä»»ä½•å¯é€‰æ–¹æ³•çš„åè®®éƒ½å¿…é¡»å®ç° `@objc`<br>
ä»»ä½•å®ç°å¯é€‰åè®®çš„ç±»éƒ½å¿…é¡»ç»§æ‰¿è‡ª `NSObject`<br>
è¿™ç±»åè®®ä¸»è¦ç”¨äºå§”æ‰˜

- åè®®æœ¬èº«çš„å£°æ˜

```swift
protocol SomeProtocol : InheritedProtocol1, InheritedProtocol2 {
    var someProperty: Int { get set }
    func aMethod(arg1: Double, anotherArgument: String) -> SomeType
    mutating func changeIt()
    init(arg: Type)
}
```

ä»»ä½•å®ç° `SomeProtocol` çš„å¯¹è±¡ï¼Œéƒ½è¦å®ç° `InheritedProtocol1` å’Œ `InheritedProtocol2`<br>
å±æ€§å¿…é¡»å…·ä½“å£°æ˜æ˜¯åªè¯» `{ get }` æˆ– è¯»å†™ `{ get set }`ã€‚ ä¾‹ï¼šç±»å‹ `Int { get set }`<br>
ä»»ä½•å¸Œæœ›æ¥æ”¶å™¨æ”¹å˜çš„å‡½æ•°éƒ½è¦æ ‡è®° `mutating` é™¤éé™åˆ¶åªç”¨äºç±»å®ç°åè®®<br>
ç”šè‡³å¯ä»¥æŒ‡å®šå®ç°è€…å®ç°åˆå§‹åŒ–è®¾å®š `init`

- åè®®çš„å®ç°

```swift
class SomeClass : SuperclassOfSomeClass, SomeProtocol, AnotherProtocol {
// implementation of SomeClass here
// which must include all the properties and methods in SomeProtocol & AnotherProtocol
    required init(...)
}

enum SomeEnum : SomeProtocol, AnotherProtocol {
// implementation of SomeEnum here
// which must include all the properties and methods in SomeProtocol & AnotherProtocol
}

struct SomeStruct : SomeProtocol, AnotherProtocol {
// implementation of SomeStruct here
// which must include all the properties and methods in SomeProtocol & AnotherProtocol
}
```

ç±»çš„åè®®å®ç°ï¼Œå®šä¹‰åœ¨ç±»çš„è¶…ç±»ä¹‹åï¼Œä½¿ç”¨ `,` åˆ†éš”<br>
ç±»ã€æšä¸¾ã€ç»“æ„ä½“éƒ½å¯ä»¥å®ç°ä»»æ„æ•°é‡çš„åè®®<br>
åœ¨ç±»ä¸­å®ç° `init` å¿…é¡»æ ‡è®° `required`  å¦åˆ™ï¼Œå­ç±»å¯èƒ½ä¸ä¸€è‡´<br>
ç”šè‡³å¯ä»¥è®©æ‰©å±•å®ç°åè®®

```swift
extension Something : SomeProtocol {
// implementation of SomeProtocol here
// no stored properties though
}
```

- åè®®çš„ä½¿ç”¨æ–¹å¼

```swift
protocol Moveable {
    mutating func move(to point: CGPoint)
}
    
class Car: Moveable {
    func move(to Point: CGPoint) { ... }
    func changeOil()
}
    
struct Shape: Moveable {
    mutating func move(to point: CGPoint) { ... }
    func draw()
}
    
let pruis: Car = Car()
let square: Shape = Shape()

// ç”¨æ³•ï¼šthingToMoveçš„ç±»å‹æ˜¯MoveableäºŒä¸æ˜¯Car
var thingToMove: Moveable = pruis
thingToMove.move(to: ...)
    
// å‡½æ•°ç”¨æ³•
func slide(sleder: Moveable) {
    let positionToSledeTo = ...
    slider.move(to: positionToSledeTo)
}
slide(prius)
slide(square)
    
// âŒé”™è¯¯ç”¨æ³•
func slipAndSlide(x: Slippery & Moveable)
slipAndSlide(pruis) // ä¸è¢«å…è®¸çš„ï¼Œå› ä¸º Car åªå®ç°äº† Moveable ï¼Œ è€Œæœªå®ç° Slippery
    
// æ³¨é‡Šï¼š& è¡¨ç¤ºå·¦å³ä¸¤è¾¹éƒ½è¦å®ç°
```

- åè®®çš„å¦ä¸€ç§å®ç°

æˆä¸ºä¸€ä¸ªå­—å…¸çš„key `Dictionary<Key: Hashable, Value>` ï¼ŒKeyéœ€è¦å®ç° `Hashable` åè®®ï¼Œç”±äº `Hashable` å®ç°äº† `Equalable` åè®®

```swift
protocol Hashable: Equatable {
    var hashValue: Int { get }
}
    
protocol Equatable {
    static func ==(lhs: Self, rhs: Self) -> Bool
}
```

å› æ­¤ï¼Œä½œä¸ºå­—å…¸Keyçš„å¯¹è±¡éœ€è¦å®ç° `Hashable` å’Œ `Equalable` ä¾‹ï¼šå°†Cardç»“æ„ä½“æ”¹æˆHashable

```swift
struct Card: Hashable {
    
    // Hashable combine å‡ ä¸ªå‚æ•°ï¼Œ== æ–¹æ³•ä¸­å°±è¦åˆ¤æ–­å‡ ä¸ªå‚æ•°
    func hash(into hasher: inout Hasher) {
        hasher.combine(identifier)
    }
    // Equatable
    static func ==(lhs: Card, rhs: Card) -> Bool {
        return lhs.identifier == rhs.identifier
    }
        
    var isFaceUp = false
    var isMatched = false
    var identifier: Int
        
    init(identifier: Int) {
        self.identifier = identifier
    }
        
    // static method
    private static var identifierFactory = 0
        
    private static func getUniqueIdentifier() -> Int {
        // static func visit static cars Without Card.identifierFactory
        identifierFactory += 1
        return identifierFactory
    }
    
    init() {
        self.identifier = Card.getUniqueIdentifier()
    }
}
```

## åè®®å’Œæ‰©å±•

- ä½¿ç”¨æ‰©å±•æä¾›åè®®æ‰©å±•

æˆ‘ä»¬è¯´åè®®å®ç°æ˜¯ç”±å®ç°ç±»å‹ï¼ˆç»“æ„ã€æšä¸¾ã€ç±»ï¼‰æä¾›çš„ã€‚ä½†æ˜¯ï¼Œå¯ä»¥ä½¿ç”¨æ‰©å±•å°†é»˜è®¤å®ç°æ·»åŠ åˆ°åè®®ä¸­ã€‚<br>
ç”±äºåè®®æ²¡æœ‰å­˜å‚¨ï¼Œæ‰€ä»¥å®ç°å¿…é¡»æ˜¯åè®®çš„å…¶ä»–Apiã€‚ï¼ˆå½“ç„¶ï¼Œè¿˜æœ‰è¯¥åè®®ç»§æ‰¿çš„ä»»ä½•åè®®ä¸­çš„ä»»ä½•APIï¼‰ã€‚

- å‡½æ•°å¼ç¼–ç¨‹

é€šè¿‡å°†åè®®ä¸æ³›å‹å’Œæ‰©å±•ï¼ˆé»˜è®¤å®ç°ï¼‰ç›¸ç»“åˆï¼Œ å¯ä»¥æ„å»ºæ›´å¤šå…³æ³¨æ•°æ®ç»“æ„è¡Œä¸ºè€Œä¸æ˜¯å­˜å‚¨çš„ä»£ç ã€‚<br>
å®ƒä¸åŒäºâ€œé¢å‘å¯¹è±¡ç¼–ç¨‹â€ï¼ˆè¿™æ˜¯å®ƒçš„ä¸€ç§è¿›åŒ–ï¼‰ã€‚ swiftçš„ä¼Ÿå¤§ä¹‹å¤„åœ¨äºå®ƒæ”¯æŒä¸¤ç§æ¨¡å¼ï¼ˆå‡½æ•°å¼ç¼–ç¨‹ä¸é¢å‘å¯¹è±¡ç¼–ç¨‹ï¼‰ã€‚

##  Delegate å§”æ‰˜

- åè®®æ˜¯ä¸€ç§åœ¨è§†å›¾å’Œæ§åˆ¶å™¨ä¹‹é—´å®ç°â€œç›²é€šä¿¡â€çš„æ–¹æ³•

- åè®®çš„ä¸€ç§éå¸¸é‡è¦ï¼ˆç®€å•ï¼‰çš„ä½¿ç”¨æ–¹å¼

## String

- å­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦

ä½¿ç”¨ `startIndex`ï¼Œ`endIndex` å’Œ `index(of:)` è¿›è¡Œç´¢å¼•ã€‚<br>
ç§»åŠ¨åˆ°å¦ä¸€ä¸ªä¸‹æ ‡ï¼Œä½¿ç”¨ `index(String.Index, offsetBy: Int)`

```swift
private var emojiChoices = "ğŸ‘»ğŸ‘½ğŸ’€ğŸƒğŸ‘¹ğŸ¤¡ğŸ¦‡ğŸ™ğŸ¦"
  
private func emoji(for card: Card) -> String {
    if emoji[card] == nil, emojiChoices.count > 0 {
        let randomStringIndex = emojiChoices.index(emojiChoices.startIndex, offsetBy: emojiChoices.count.arc4random)
        emoji[card] = String(emojiChoices.remove(at: randomStringIndex))
    }
    return emoji[card] ?? "?"
}
```

- å­—ç¬¦ä¸²æ˜¯å€¼ç±»å‹ï¼ˆå®ƒæ˜¯ä¸€ä¸ª`struct`ï¼‰

```swift
var s = pizzaJoint // makes a mutable copy of pizzaJoint (because itâ€™s a value type!) 
s.insert(contentsOf: â€œ fooâ€, at: s.index(of: â€œ â€œ)!) // cafeÌ foo pesto
```

- å…¶ä»–æ–¹æ³•

```swift
func hasPrefix(String) -> Bool
func hasSuffix(String) -> Bool
var localizedCapitalized/Lowercase/Uppercase: String
func replaceSubrange(Range<String.Index>, with: Collection of Character) 
// e.g., s.replaceSubrange(..<s.endIndex, with: â€œnew contentsâ€)
```

## NSAttributedString

- éå€¼ç±»å‹ï¼Œæ‰€ä»¥ä¸èƒ½ä»…ä½¿ç”¨varå®šä¹‰ï¼Œå¦‚æœæƒ³æ”¹å˜å€¼ï¼Œéœ€è¦ä½¿ç”¨å…¶å­ç±» `NSMutableAttributedString`

```swift
let attibuteKey: [NSAttributedString.Key: Any] = [
    .strokeWidth: 5.0,
    .strokeColor: #colorLiteral(red: 1, green: 0.5763723254, blue: 0, alpha: 1)
    ]
let attribtext = NSAttributedString(string: "Flips: \(flipCount)", attributes: attibuteKey) 
flipCountLabel.attributedText = attribtext // UIButton has attributedTitle
```

## é—­åŒ…  Closures åŠå…¶æ¼”å˜

```swift
var operation: (Double) -> Double
operation = (operand: Double) -> Double { return -operand }
let result = operation(4.0) // result will be -4.0
```

ä¸€ä¸ªå°è¯­æ³•å˜åŒ–ï¼šæŠŠç¬¬ä¸€ä¸ª `{` ç§»åŠ¨åˆ°å¼€å¤´ï¼Œå¹¶æ›¿æ¢ä¸º `in`

```swift
operation = { (operand: Double) -> Double in return -operand }
```

swift èƒ½è‡ªåŠ¨åˆ¤æ–­è¿”å›ç±»å‹å’Œæ“ä½œæ•°ç±»å‹ä¸ºä¸€ä¸ª `Double`

```swift
operation = { (operand) in return -operand }
```

swift è¿˜èƒ½åˆ¤æ–­ `operation` ä¼šè¿”å›ä¸€ä¸ªå€¼ï¼Œreturn ä¹Ÿéå¿…é¡»

```swift
operation = { (operand) in -operand }
```

swift è¿˜å…è®¸ä½¿ç”¨ `$0, $1, $2` ç­‰æ›¿æ¢å‚æ•°åï¼Œå¹¶è·³è¿‡ inã€‚ è¿™æ˜¯æœ€ç®€æ´å†™æ³•

```swift
operation = { -$0 } 
```

negative: è¡¨ç¤º è´Ÿ -2<br>
open parenthesis: å·¦æ‹¬å· (<br>
closed: å³æ‹¬å· ) , ä¸ `open parenthesis` åŒæ—¶å‡ºç°å¯ä»¥ç¼©å†™ï¼Œå¦åˆ™å†™ä½œ `close parenthesis`

- é—­åŒ…æ˜¯å¼•ç”¨ç±»å‹

é—­åŒ…å¯ä»¥ä½¿ç”¨å±€éƒ¨å˜é‡(`local variables`)æˆ–å®ä¾‹å˜é‡(`instance variables`)ï¼Œæˆ–è€…å…¶ä»–ä»€ä¹ˆï¼ˆå¦‚`class`ï¼‰ï¼Œå¹¶ä¸”ï¼Œå½“è¯¥é—­åŒ…è¢«å¯¼å‡ºä¼ é€’æ—¶ï¼Œå…¶åŒ…å«çš„å˜é‡ä¾ç„¶æœ‰æ•ˆï¼Œç›´åˆ°é—­åŒ…æ¶ˆå¤±

â‰ï¸ï¼šSwift ä¸­æœ‰ä¸¤ç§å¼•ç”¨ç±»å‹ï¼šClass å’Œ closures ( ç±» å’Œ é—­åŒ… )
